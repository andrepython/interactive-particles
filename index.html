<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Andre Python - Smooth Morph & Explosion</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: #000;
    display: flex; justify-content: center; align-items: center; height: 100vh;
    font-family: 'Roboto', sans-serif;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
}
resize();
window.addEventListener('resize', resize);

const offCanvas = document.createElement('canvas');
const offCtx = offCanvas.getContext('2d');

const fontSize = 120;
offCanvas.width = 800;
offCanvas.height = 200;

function getTextData(text) {
  offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
  offCtx.font = `bold ${fontSize}px 'Roboto', sans-serif`;
  offCtx.fillStyle = 'white';
  offCtx.textBaseline = 'middle';
  offCtx.textAlign = 'center';
  offCtx.fillText(text, offCanvas.width / 2, offCanvas.height / 2);
  const imageData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
  
  const points = [];
  for(let y = 0; y < offCanvas.height; y += 3){
    for(let x = 0; x < offCanvas.width; x += 3){
      const index = (y * offCanvas.width + x) * 4;
      if(imageData.data[index + 3] > 128) {
        const posX = x + (width - offCanvas.width) / 2;
        const posY = y + (height - offCanvas.height) / 2;
        points.push({ tx: posX, ty: posY });
      }
    }
  }
  return points;
}

let words = ["Welcome", "Bienvenue"];
let currentWordIndex = 0;
let particles = [];
let targetPoints = getTextData(words[currentWordIndex]);

// Create particles
for(let i = 0; i < targetPoints.length; i++){
  particles.push({
    x: Math.random() * width,
    y: Math.random() * height,
    tx: targetPoints[i].tx,
    ty: targetPoints[i].ty,
    vx: 0,
    vy: 0
  });
}

// Color animation
let colorPhase = 0;

// Explosion effect
function explodeParticles() {
  particles.forEach(p => {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 2; // gentler explosion
    p.vx = Math.cos(angle) * speed;
    p.vy = Math.sin(angle) * speed;
  });
}

function morphToNextWord() {
  currentWordIndex = (currentWordIndex + 1) % words.length;
  targetPoints = getTextData(words[currentWordIndex]);
  
  // Adjust particle count
  if(targetPoints.length > particles.length){
    for(let i = particles.length; i < targetPoints.length; i++){
      particles.push({
        x: Math.random() * width,
        y: Math.random() * height,
        tx: targetPoints[i].tx,
        ty: targetPoints[i].ty,
        vx: 0,
        vy: 0
      });
    }
  } else if(targetPoints.length < particles.length){
    particles = particles.slice(0, targetPoints.length);
  }
  
  // Assign new target positions
  particles.forEach((p, i) => {
    p.tx = targetPoints[i].tx;
    p.ty = targetPoints[i].ty;
  });
}

function animate() {
  ctx.clearRect(0, 0, width, height);
  
  // Slow color shift
  colorPhase += 0.005; // smaller = slower
  const lightness = 20 + Math.sin(colorPhase) * 20; // very dark to mid blue
  const color = `hsl(200, 100%, ${lightness}%)`;

  particles.forEach(p => {
    const dx = p.tx - p.x;
    const dy = p.ty - p.y;
    p.vx += dx * 0.05; // smaller = slower morph
    p.vy += dy * 0.05;
    p.vx *= 0.8; // friction
    p.vy *= 0.8;
    p.x += p.vx;
    p.y += p.vy;

    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
    ctx.fill();
  });
  
  requestAnimationFrame(animate);
}

animate();

// Timeline: explosion -> morph
setInterval(() => {
  explodeParticles();
  setTimeout(morphToNextWord, 800); // morph after explosion
}, 5000); // delay between word switches
</script>
</body>
</html>
